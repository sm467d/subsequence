<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>subsequence</title>
  <link rel="icon" type="image/svg+xml" href="branding/favicon.svg">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Archivo:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #0a0a0a;
      color: #ffffff;
      font-family: 'Archivo', sans-serif;
      min-height: 100vh;
      user-select: none;
    }

    header {
      display: flex;
      align-items: center;
      padding: 16px 28px;
      gap: 32px;
      border-bottom: 1px solid #1a1a1a;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 10px;
      text-decoration: none;
      cursor: pointer;
    }

    .logo-text {
      font-size: 15px;
      font-weight: 500;
      letter-spacing: 0.04em;
      color: #ffffff;
      opacity: 0.9;
    }

    .logo-icon {
      width: 20px;
      height: 20px;
      opacity: 0.85;
    }

    nav {
      display: flex;
      gap: 6px;
    }

    nav a {
      color: #555555;
      text-decoration: none;
      font-size: 14px;
      font-weight: 500;
      letter-spacing: 0.03em;
      padding: 8px 20px;
      cursor: pointer;
    }

    nav a:hover {
      color: #999999;
    }

    nav a.active {
      color: #ffffff;
      border-bottom: 1px solid #ffffff;
    }

    .nav-right {
      margin-left: auto;
    }

    main {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 28px;
    }

    /* auth */
    .auth-form {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 25vh;
      width: 260px;
    }

    .auth-title {
      font-size: 14px;
      color: #888888;
      letter-spacing: 0.04em;
      margin-bottom: 4px;
    }

    .auth-input {
      background: #141414;
      border: 1px solid #333333;
      color: #ffffff;
      font-family: inherit;
      font-size: 14px;
      padding: 10px 14px;
      outline: none;
      letter-spacing: 0.03em;
    }

    .auth-input:focus {
      border-color: #ffffff;
    }

    .auth-input::placeholder {
      color: #444444;
    }

    .auth-submit {
      background: none;
      border: 1px solid #333333;
      color: #888888;
      font-family: inherit;
      font-size: 14px;
      font-weight: 500;
      padding: 10px 24px;
      cursor: pointer;
      letter-spacing: 0.03em;
    }

    .auth-submit:hover {
      color: #ffffff;
      border-color: #ffffff;
    }

    .auth-error {
      font-size: 12px;
      color: #ef4444;
      letter-spacing: 0.03em;
    }

    .auth-toggle {
      font-size: 12px;
      color: #555555;
      cursor: pointer;
      letter-spacing: 0.03em;
    }

    .auth-toggle:hover {
      color: #999999;
    }

    /* mode selector */
    .mode-select {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      margin-top: 25vh;
    }

    .mode-row {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: center;
      min-height: 42px;
    }

    .mode-row-label {
      font-size: 11px;
      color: #333333;
      letter-spacing: 0.06em;
      width: 60px;
      text-align: right;
      margin-right: 8px;
    }

    .mode-row-label.hidden {
      visibility: hidden;
    }

    .mode-btn {
      background: none;
      border: 1px solid #333333;
      color: #888888;
      font-family: inherit;
      font-size: 14px;
      font-weight: 500;
      padding: 10px 24px;
      cursor: pointer;
      letter-spacing: 0.03em;
    }

    .mode-btn.hidden {
      visibility: hidden;
    }

    .mode-btn:hover {
      color: #ffffff;
      border-color: #ffffff;
    }

    .mode-btn.selected {
      color: #ffffff;
      border-color: #ffffff;
    }

    /* hud */
    .hud {
      display: flex;
      justify-content: space-between;
      width: 100%;
      max-width: min(55vw, 55vh);
      margin-bottom: 12px;
      font-size: 13px;
      font-weight: 500;
      letter-spacing: 0.05em;
      color: #555555;
    }

    .hud-score { color: #ffffff; }
    .hud-timer { color: #ffffff; }
    .hud-mode { color: #555555; }

    /* grid */
    .grid {
      display: grid;
      width: min(55vw, 55vh);
      height: min(55vw, 55vh);
      cursor: crosshair;
    }

    .cell {
      background: #141414;
      border: 1px solid #0a0a0a;
      cursor: crosshair;
    }

    .cell.target {
      background: #ffffff;
    }

    /* drag game */
    .cell.drag-source {
      background: #22c55e;
      cursor: grab;
    }

    .cell.drag-source-dragging {
      opacity: 0.3;
    }

    .cell.drag-target {
      background: #ffffff;
    }

    .drag-ghost {
      position: fixed;
      background: #22c55e;
      pointer-events: none;
      z-index: 1000;
      opacity: 0.85;
    }

    body.drag-track, body.drag-track * {
      cursor: grab !important;
    }

    body.dragging, body.dragging * {
      cursor: grabbing !important;
    }

    /* results */
    .results {
      margin-top: 60px;
      text-align: center;
    }

    .results-score {
      font-size: 48px;
      font-weight: 600;
      letter-spacing: -0.02em;
    }

    .results-label {
      font-size: 13px;
      color: #555555;
      letter-spacing: 0.05em;
      margin-top: 4px;
    }

    .results-stats {
      display: flex;
      gap: 32px;
      justify-content: center;
      margin-top: 24px;
      font-size: 14px;
      color: #888888;
    }

    .results-stats span {
      color: #ffffff;
    }

    .results-new-best {
      font-size: 12px;
      color: #22c55e;
      letter-spacing: 0.05em;
      margin-top: 8px;
    }

    .again-btn {
      background: none;
      border: 1px solid #333333;
      color: #888888;
      font-family: inherit;
      font-size: 13px;
      font-weight: 500;
      padding: 8px 24px;
      cursor: pointer;
      letter-spacing: 0.03em;
      margin-top: 32px;
    }

    .again-btn:hover {
      color: #ffffff;
      border-color: #ffffff;
    }

    /* history */
    .history {
      margin-top: 40px;
      width: 100%;
      max-width: 400px;
    }

    .history-title {
      font-size: 12px;
      color: #555555;
      letter-spacing: 0.06em;
      margin-bottom: 12px;
    }

    .history-row {
      display: flex;
      justify-content: space-between;
      padding: 6px 0;
      font-size: 13px;
      border-bottom: 1px solid #141414;
    }

    .history-rank {
      color: #333333;
      width: 24px;
    }

    .history-score {
      color: #ffffff;
      flex: 1;
    }

    .history-acc {
      color: #555555;
      width: 60px;
      text-align: right;
    }

    .history-date {
      color: #333333;
      width: 80px;
      text-align: right;
    }

    /* settings */
    .settings {
      width: 100%;
      max-width: 400px;
      margin-top: 48px;
    }

    .settings-section {
      margin-bottom: 32px;
    }

    .settings-label {
      font-size: 13px;
      color: #555555;
      letter-spacing: 0.05em;
      margin-bottom: 12px;
    }

    .sound-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .sound-row {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 8px 12px;
      cursor: pointer;
      border: 1px solid transparent;
    }

    .sound-row:hover {
      border-color: #333333;
    }

    .sound-row.selected {
      border-color: #ffffff;
    }

    .sound-name {
      font-size: 14px;
      color: #888888;
      flex: 1;
    }

    .sound-row.selected .sound-name {
      color: #ffffff;
    }

    .sound-test {
      background: none;
      border: 1px solid #333333;
      color: #555555;
      font-family: inherit;
      font-size: 11px;
      padding: 4px 12px;
      cursor: pointer;
      letter-spacing: 0.03em;
    }

    .sound-test:hover {
      color: #ffffff;
      border-color: #ffffff;
    }

    /* track */
    .track-arena {
      width: min(55vw, 55vh);
      height: min(55vw, 55vh);
      background: #141414;
      position: relative;
      cursor: crosshair;
      overflow: hidden;
    }

    .track-target {
      position: absolute;
      background: #ffffff;
    }

    /* edit track */
    .edit-editor {
      width: min(55vw, 55vh);
      min-height: 200px;
      background: #141414;
      border: 1px solid #333333;
      color: #ffffff;
      font-family: 'Archivo', monospace;
      font-size: 15px;
      line-height: 1.7;
      padding: 20px 24px;
      outline: none;
      white-space: pre-wrap;
      word-wrap: break-word;
      caret-color: #ffffff;
      letter-spacing: 0.01em;
      user-select: text;
      -webkit-user-select: text;
    }

    .edit-caret-target {
      position: relative;
    }

    .edit-caret-target::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 2px;
      background: #3b82f6;
      animation: edit-blink 1s step-end infinite;
    }

    @keyframes edit-blink {
      50% { opacity: 0; }
    }

    .edit-hl-select {
      background: rgba(234, 179, 8, 0.25);
    }

    .edit-hl-delete {
      background: rgba(239, 68, 68, 0.25);
    }

    .edit-hl-replace-src {
      background: rgba(239, 68, 68, 0.25);
    }

    .edit-hl-replace-dst {
      position: relative;
      background: rgba(34, 197, 94, 0.25);
    }

    .edit-hl-replace-dst::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 2px;
      background: #22c55e;
    }

    .edit-hint {
      width: min(55vw, 55vh);
      font-size: 12px;
      color: #333333;
      letter-spacing: 0.04em;
      margin-top: 8px;
      text-align: center;
    }
  </style>
</head>
<body>
  <header>
    <a href="/" class="logo">
      <img src="branding/logo.svg" alt="subsequence" class="logo-icon">
      <span class="logo-text">subsequence</span>
    </a>
    <nav>
      <a href="#grid" data-tab="grid" class="active">grid</a>
      <a href="#drag" data-tab="drag">drag</a>
      <a href="#track" data-tab="track">track</a>
      <a href="#edit" data-tab="edit">edit</a>
      <a href="#settings" data-tab="settings" class="nav-right">settings</a>
    </nav>
  </header>
  <main id="content"></main>

  <script>
    // supabase
    var sb = supabase.createClient(
      'https://ebbciupfgmicgxpzxcnv.supabase.co',
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImViYmNpdXBmZ21pY2d4cHp4Y252Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzE3MTYxMjAsImV4cCI6MjA4NzI5MjEyMH0.j6BJb_BeaPwZhdV2Fqpt1dFawhxvB4BbzMBBRUaaTdY'
    );

    var currentUser = null;
    var content = document.getElementById('content');
    var gameTimer = null;
    var gameState = null;
    var gameCleanup = null;

    // selected mode/duration/grid — persisted
    var selectedMode = localStorage.getItem('subsequence_mode') || 'time';
    var selectedDuration = parseInt(localStorage.getItem('subsequence_duration')) || 30;
    var selectedGrid = parseInt(localStorage.getItem('subsequence_grid')) || 9;

    // track persisted
    var selectedTrackDuration = parseInt(localStorage.getItem('subsequence_track_duration')) || 30;
    var selectedTrackSize = localStorage.getItem('subsequence_track_size') || 'medium';
    var selectedTrackDifficulty = localStorage.getItem('subsequence_track_difficulty') || 'normal';
    var trackAnimFrame = null;
    var trackSoundInterval = null;

    // edit track state
    var editState = null;
    var editTimer = null;
    var selectedEditDrills = JSON.parse(localStorage.getItem('subsequence_edit_drills') || '["movement","selection","deletion","replace"]');
    var selectedEditDuration = parseInt(localStorage.getItem('subsequence_edit_duration')) || 30;

    var editTextBlocks = [
      "The quick brown fox jumps over the lazy dog near the riverbank. Every morning the fox would wake up and stretch before heading out to find breakfast. The dog never seemed to mind the fox running past. They had developed an understanding over the years. Sometimes the fox would bring back a small fish from the river and leave it near the sleeping dog as a quiet gesture of friendship.",
      "Software engineers often spend more time reading code than writing it. Understanding existing patterns in a codebase is essential before making changes. A good developer reads the test suite first to understand expected behavior. Then they trace through the implementation to find the right place to make modifications. Only after this exploration do they begin writing new code.",
      "The city lights reflected off the wet pavement as rain continued to fall. People hurried along the sidewalks with umbrellas and jackets pulled tight. A musician played guitar under the awning of a bookstore. The melody drifted through the rain and mixed with the sound of passing cars. A few people stopped to listen before continuing on their way home through the evening.",
      "Learning to type efficiently is only the first step in computer productivity. The real gains come from mastering text navigation and manipulation shortcuts. Moving by words instead of characters saves hundreds of keystrokes per day. Selecting entire lines with a single command eliminates tedious click and drag operations. These small improvements compound into significant time savings over months and years.",
      "The research team published their findings after three years of careful study. Their data showed a clear correlation between practice frequency and skill improvement. Participants who trained for short sessions daily outperformed those who trained in long weekly sessions. The key factor was consistency rather than total time invested. Regular practice built stronger neural pathways than occasional intensive effort."
    ];

    // sounds
    var sounds = [
      { id: 'none', name: 'none' },
      { id: 'click_1', name: 'click 1', file: 'sounds/click_1.wav' },
      { id: 'click_2', name: 'click 2', file: 'sounds/click_2.wav' },
      { id: 'click_3', name: 'click 3', file: 'sounds/click_3.wav' },
      { id: 'click_4', name: 'click 4', file: 'sounds/click_4.wav' },
      { id: 'click_5', name: 'click 5', file: 'sounds/click_5.wav' },
      { id: 'click_6', name: 'click 6', file: 'sounds/click_6.wav' }
    ];

    var selectedSound = 'click_1';
    var audioCache = {};

    function preloadSounds() {
      sounds.forEach(function(s) {
        if (s.file) {
          var a = new Audio(s.file);
          a.preload = 'auto';
          audioCache[s.id] = a;
        }
      });
    }
    preloadSounds();

    function playHitSound() {
      if (selectedSound === 'none') return;
      var cached = audioCache[selectedSound];
      if (!cached) return;
      var clone = cached.cloneNode();
      clone.volume = 1;
      clone.play();
    }

    async function loadSoundSetting() {
      if (!currentUser) return;
      var { data } = await sb.from('user_settings').select('sound').eq('user_id', currentUser.id).single();
      if (data) {
        selectedSound = data.sound;
      } else {
        // no settings row yet — create one
        await sb.from('user_settings').insert({ user_id: currentUser.id, sound: 'click_1' });
      }
    }

    async function saveSoundSetting(id) {
      selectedSound = id;
      if (!currentUser) return;
      await sb.from('user_settings').upsert({ user_id: currentUser.id, sound: id, updated_at: new Date().toISOString() });
    }

    // auth
    async function initAuth() {
      var { data } = await sb.auth.getSession();
      if (data && data.session) {
        currentUser = data.session.user;
        await loadSoundSetting();
        onAuthReady();
      } else {
        showAuth('sign up');
      }
    }

    function showAuth(mode) {
      content.innerHTML = '';
      var form = document.createElement('div');
      form.className = 'auth-form';

      var title = document.createElement('div');
      title.className = 'auth-title';
      title.textContent = mode;
      form.appendChild(title);

      var usernameInput = document.createElement('input');
      usernameInput.className = 'auth-input';
      usernameInput.type = 'text';
      usernameInput.placeholder = 'username';
      usernameInput.autocomplete = 'username';
      form.appendChild(usernameInput);

      var passInput = document.createElement('input');
      passInput.className = 'auth-input';
      passInput.type = 'password';
      passInput.placeholder = 'password';
      passInput.autocomplete = mode === 'sign up' ? 'new-password' : 'current-password';
      form.appendChild(passInput);

      var confirmInput = null;
      if (mode === 'sign up') {
        confirmInput = document.createElement('input');
        confirmInput.className = 'auth-input';
        confirmInput.type = 'password';
        confirmInput.placeholder = 'confirm password';
        confirmInput.autocomplete = 'new-password';
        form.appendChild(confirmInput);
      }

      var errorEl = document.createElement('div');
      errorEl.className = 'auth-error';
      form.appendChild(errorEl);

      var submit = document.createElement('button');
      submit.className = 'auth-submit';
      submit.textContent = mode;
      form.appendChild(submit);

      var toggle = document.createElement('div');
      toggle.className = 'auth-toggle';
      toggle.textContent = mode === 'sign up' ? 'already have an account? sign in' : 'need an account? sign up';
      toggle.addEventListener('click', function() {
        showAuth(mode === 'sign up' ? 'sign in' : 'sign up');
      });
      form.appendChild(toggle);

      async function doAuth() {
        var username = usernameInput.value.trim().toLowerCase();
        var password = passInput.value;
        errorEl.textContent = '';

        if (!username) { errorEl.textContent = 'enter a username'; return; }
        if (password.length < 6) { errorEl.textContent = 'password must be at least 6 characters'; return; }

        var email = username + '@subsequence.gg';

        if (mode === 'sign up') {
          if (password !== confirmInput.value) { errorEl.textContent = 'passwords do not match'; return; }
          var { data, error } = await sb.auth.signUp({ email: email, password: password });
          if (error) { errorEl.textContent = error.message; return; }
          if (data && data.session) {
            currentUser = data.session.user;
            // create default settings (session must be active for RLS)
            var { error: settingsErr } = await sb.from('user_settings').insert({ user_id: currentUser.id, sound: 'click_1' });
            if (settingsErr) console.error('settings insert error:', settingsErr);
            await loadSoundSetting();
            onAuthReady();
          } else if (data && data.user) {
            // fallback if session not returned but user exists (auto-sign-in)
            currentUser = data.user;
            onAuthReady();
          }
        } else {
          var { data, error } = await sb.auth.signInWithPassword({ email: email, password: password });
          if (error) { errorEl.textContent = error.message; return; }
          if (data && data.user) {
            currentUser = data.user;
            await loadSoundSetting();
            onAuthReady();
          }
        }
      }

      submit.addEventListener('click', doAuth);
      form.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') doAuth();
      });

      content.appendChild(form);
      usernameInput.focus();
    }

    function onAuthReady() {
      var hash = window.location.hash.slice(1) || 'grid';
      showTab(hash);
    }

    // nav
    document.querySelectorAll('nav a').forEach(function(a) {
      a.addEventListener('click', function() {
        if (!currentUser) return;
        document.querySelector('nav a.active').classList.remove('active');
        this.classList.add('active');
        showTab(this.dataset.tab);
      });
    });

    function showTab(tab) {
      if (gameTimer) { clearInterval(gameTimer); gameTimer = null; }
      if (gameCleanup) { gameCleanup(); gameCleanup = null; }
      document.body.classList.remove('drag-track');
      if (trackAnimFrame) { cancelAnimationFrame(trackAnimFrame); trackAnimFrame = null; }
      if (trackSoundInterval) { clearInterval(trackSoundInterval); trackSoundInterval = null; }
      if (editTimer) { clearInterval(editTimer); editTimer = null; }
      document.removeEventListener('selectionchange', editSelectionHandler);
      editState = null;
      if (tab === 'grid') showModeSelect('grid');
      else if (tab === 'drag') showModeSelect('drag');
      else if (tab === 'track') showTrackModeSelect();
      else if (tab === 'edit') showEditModeSelect();
      else if (tab === 'settings') showSettings();
      else content.innerHTML = '';
    }

    // mode select
    function showModeSelect(track) {
      content.innerHTML = '';
      var wrap = document.createElement('div');
      wrap.className = 'mode-select';

      // row 1: mode
      var row1 = document.createElement('div');
      row1.className = 'mode-row';
      var label1 = document.createElement('div');
      label1.className = 'mode-row-label';
      label1.textContent = 'mode';
      row1.appendChild(label1);

      var timeRow; // reference for toggling

      ['time', 'perfection'].forEach(function(m) {
        var btn = document.createElement('button');
        btn.className = 'mode-btn' + (m === selectedMode ? ' selected' : '');
        btn.textContent = m;
        btn.addEventListener('mousedown', function() {
          selectedMode = m;
          localStorage.setItem('subsequence_mode', m);
          row1.querySelectorAll('.mode-btn').forEach(function(b) { b.classList.remove('selected'); });
          btn.classList.add('selected');
          // toggle time row visibility
          toggleTimeRow();
        });
        row1.appendChild(btn);
      });
      wrap.appendChild(row1);

      // row 2: duration (hidden for perfection, but preserves space)
      var row2 = document.createElement('div');
      row2.className = 'mode-row';
      timeRow = row2;
      var label2 = document.createElement('div');
      label2.className = 'mode-row-label';
      label2.textContent = 'time';
      row2.appendChild(label2);
      [{v: 30, l: '30s'}, {v: 60, l: '1m'}, {v: 180, l: '3m'}].forEach(function(d) {
        var btn = document.createElement('button');
        btn.className = 'mode-btn' + (d.v === selectedDuration ? ' selected' : '');
        btn.textContent = d.l;
        btn.addEventListener('mousedown', function() {
          selectedDuration = d.v;
          localStorage.setItem('subsequence_duration', d.v);
          row2.querySelectorAll('.mode-btn').forEach(function(b) { b.classList.remove('selected'); });
          btn.classList.add('selected');
        });
        row2.appendChild(btn);
      });
      wrap.appendChild(row2);

      function toggleTimeRow() {
        var els = row2.querySelectorAll('.mode-btn, .mode-row-label');
        els.forEach(function(el) {
          if (selectedMode === 'perfection') el.classList.add('hidden');
          else el.classList.remove('hidden');
        });
      }
      toggleTimeRow();

      // row 3: grid size (select only, no auto-start)
      var row3 = document.createElement('div');
      row3.className = 'mode-row';
      var label3 = document.createElement('div');
      label3.className = 'mode-row-label';
      label3.textContent = 'grid';
      row3.appendChild(label3);
      [3, 4, 6, 9, 12, 24, 48].forEach(function(n) {
        var btn = document.createElement('button');
        btn.className = 'mode-btn' + (n === selectedGrid ? ' selected' : '');
        btn.textContent = n + 'x' + n;
        btn.addEventListener('mousedown', function() {
          selectedGrid = n;
          localStorage.setItem('subsequence_grid', n);
          row3.querySelectorAll('.mode-btn').forEach(function(b) { b.classList.remove('selected'); });
          btn.classList.add('selected');
          // update continue button text
          cont.textContent = 'start — ' + n + 'x' + n;
        });
        row3.appendChild(btn);
      });
      wrap.appendChild(row3);

      // continue/start button
      var cont = document.createElement('button');
      cont.className = 'mode-btn';
      cont.textContent = 'start — ' + selectedGrid + 'x' + selectedGrid;
      cont.style.marginTop = '16px';
      cont.addEventListener('mousedown', function() {
        if (track === 'drag') startDragGame(selectedGrid);
        else startGame(selectedGrid);
      });
      wrap.appendChild(cont);

      content.appendChild(wrap);
    }

    // settings
    function showSettings() {
      content.innerHTML = '';
      var wrap = document.createElement('div');
      wrap.className = 'settings';

      var section = document.createElement('div');
      section.className = 'settings-section';

      var label = document.createElement('div');
      label.className = 'settings-label';
      label.textContent = 'hit sound';
      section.appendChild(label);

      var list = document.createElement('div');
      list.className = 'sound-list';

      sounds.forEach(function(s) {
        var row = document.createElement('div');
        row.className = 'sound-row' + (s.id === selectedSound ? ' selected' : '');

        var name = document.createElement('div');
        name.className = 'sound-name';
        name.textContent = s.name;
        row.appendChild(name);

        if (s.file) {
          var test = document.createElement('button');
          test.className = 'sound-test';
          test.textContent = 'test';
          test.addEventListener('click', function(e) {
            e.stopPropagation();
            var a = audioCache[s.id];
            if (a) { var c = a.cloneNode(); c.volume = 1; c.play(); }
          });
          row.appendChild(test);
        }

        row.addEventListener('click', function() {
          list.querySelectorAll('.sound-row').forEach(function(r) { r.classList.remove('selected'); });
          row.classList.add('selected');
          saveSoundSetting(s.id);
        });

        list.appendChild(row);
      });

      section.appendChild(list);
      wrap.appendChild(section);
      content.appendChild(wrap);
    }

    // track mode select
    function showTrackModeSelect() {
      content.innerHTML = '';
      var wrap = document.createElement('div');
      wrap.className = 'mode-select';

      // row 1: duration
      var row1 = document.createElement('div');
      row1.className = 'mode-row';
      var label1 = document.createElement('div');
      label1.className = 'mode-row-label';
      label1.textContent = 'time';
      row1.appendChild(label1);
      [{v: 30, l: '30s'}, {v: 60, l: '1m'}, {v: 180, l: '3m'}].forEach(function(d) {
        var btn = document.createElement('button');
        btn.className = 'mode-btn' + (d.v === selectedTrackDuration ? ' selected' : '');
        btn.textContent = d.l;
        btn.addEventListener('mousedown', function() {
          selectedTrackDuration = d.v;
          localStorage.setItem('subsequence_track_duration', d.v);
          row1.querySelectorAll('.mode-btn').forEach(function(b) { b.classList.remove('selected'); });
          btn.classList.add('selected');
        });
        row1.appendChild(btn);
      });
      wrap.appendChild(row1);

      // row 2: target size
      var row2 = document.createElement('div');
      row2.className = 'mode-row';
      var label2 = document.createElement('div');
      label2.className = 'mode-row-label';
      label2.textContent = 'target';
      row2.appendChild(label2);
      ['small', 'medium', 'large'].forEach(function(s) {
        var btn = document.createElement('button');
        btn.className = 'mode-btn' + (s === selectedTrackSize ? ' selected' : '');
        btn.textContent = s;
        btn.addEventListener('mousedown', function() {
          selectedTrackSize = s;
          localStorage.setItem('subsequence_track_size', s);
          row2.querySelectorAll('.mode-btn').forEach(function(b) { b.classList.remove('selected'); });
          btn.classList.add('selected');
        });
        row2.appendChild(btn);
      });
      wrap.appendChild(row2);

      // row 3: difficulty
      var row3 = document.createElement('div');
      row3.className = 'mode-row';
      var label3 = document.createElement('div');
      label3.className = 'mode-row-label';
      label3.textContent = 'difficulty';
      row3.appendChild(label3);
      ['easy', 'normal', 'hard'].forEach(function(d) {
        var btn = document.createElement('button');
        btn.className = 'mode-btn' + (d === selectedTrackDifficulty ? ' selected' : '');
        btn.textContent = d;
        btn.addEventListener('mousedown', function() {
          selectedTrackDifficulty = d;
          localStorage.setItem('subsequence_track_difficulty', d);
          row3.querySelectorAll('.mode-btn').forEach(function(b) { b.classList.remove('selected'); });
          btn.classList.add('selected');
        });
        row3.appendChild(btn);
      });
      wrap.appendChild(row3);

      // start button
      var cont = document.createElement('button');
      cont.className = 'mode-btn';
      cont.textContent = 'start';
      cont.style.marginTop = '16px';
      cont.addEventListener('mousedown', function() { startTrackGame(); });
      wrap.appendChild(cont);

      content.appendChild(wrap);
    }

    // track game
    function startTrackGame() {
      var duration = selectedTrackDuration;
      var targetPx = selectedTrackSize === 'small' ? 20 : selectedTrackSize === 'large' ? 60 : 40;
      // difficulty: controls speed + how often/sharply the target changes direction
      var diffSettings = {
        easy:   { speed: 180, changeChance: 0.005, nudgeRange: 0.3 },
        normal: { speed: 250, changeChance: 0.02,  nudgeRange: 0.5 },
        hard:   { speed: 320, changeChance: 0.06,  nudgeRange: 1.2 }
      };
      var diff = diffSettings[selectedTrackDifficulty] || diffSettings.normal;
      var speed = diff.speed;

      var trackState = {
        duration: duration,
        timeLeft: duration,
        totalFrames: 0,
        onTargetFrames: 0,
        isOnTarget: false,
        cursorX: -1,
        cursorY: -1,
        mouseDown: false
      };

      content.innerHTML = '';

      // hud
      var hud = document.createElement('div');
      hud.className = 'hud';
      var timeLabel = duration >= 60 ? Math.floor(duration / 60) + ':' + ('0' + (duration % 60)).slice(-2) : duration + 's';
      hud.innerHTML = '<div class="hud-score">0%</div><div class="hud-mode">track</div><div class="hud-timer">' + timeLabel + '</div>';
      content.appendChild(hud);

      // arena
      var arena = document.createElement('div');
      arena.className = 'track-arena';
      content.appendChild(arena);

      // target
      var target = document.createElement('div');
      target.className = 'track-target';
      target.style.width = targetPx + 'px';
      target.style.height = targetPx + 'px';
      arena.appendChild(target);

      // initial position — center
      var arenaRect = arena.getBoundingClientRect();
      var arenaW = arenaRect.width;
      var arenaH = arenaRect.height;
      var tx = (arenaW - targetPx) / 2;
      var ty = (arenaH - targetPx) / 2;
      target.style.left = tx + 'px';
      target.style.top = ty + 'px';

      // random initial velocity
      var angle = Math.random() * Math.PI * 2;
      var vx = Math.cos(angle) * speed;
      var vy = Math.sin(angle) * speed;

      // track cursor
      arena.addEventListener('mousemove', function(e) {
        var r = arena.getBoundingClientRect();
        trackState.cursorX = e.clientX - r.left;
        trackState.cursorY = e.clientY - r.top;
      });

      arena.addEventListener('mouseleave', function() {
        trackState.cursorX = -1;
        trackState.cursorY = -1;
      });

      arena.addEventListener('mousedown', function(e) {
        e.preventDefault();
        trackState.mouseDown = true;
      });

      document.addEventListener('mouseup', function() {
        trackState.mouseDown = false;
      });

      // sound interval — fires rapidly while on target
      trackSoundInterval = null;

      function startTrackSound() {
        if (trackSoundInterval) return;
        playHitSound();
        trackSoundInterval = setInterval(playHitSound, 90);
      }

      function stopTrackSound() {
        if (trackSoundInterval) {
          clearInterval(trackSoundInterval);
          trackSoundInterval = null;
        }
      }

      // timer
      gameTimer = setInterval(function() {
        trackState.timeLeft--;
        var tl = trackState.timeLeft;
        var display = tl >= 60 ? Math.floor(tl / 60) + ':' + ('0' + (tl % 60)).slice(-2) : tl + 's';
        hud.querySelector('.hud-timer').textContent = display;
        if (trackState.timeLeft <= 0) {
          clearInterval(gameTimer);
          gameTimer = null;
          cancelAnimationFrame(trackAnimFrame);
          trackAnimFrame = null;
          stopTrackSound();
          endTrackGame(trackState);
        }
      }, 1000);

      // game loop
      var lastTime = performance.now();

      function loop(now) {
        var dt = (now - lastTime) / 1000;
        lastTime = now;
        if (dt > 0.1) dt = 0.1; // clamp big gaps

        // move target
        tx += vx * dt;
        ty += vy * dt;

        // bounce
        if (tx <= 0) { tx = 0; vx = Math.abs(vx); }
        if (ty <= 0) { ty = 0; vy = Math.abs(vy); }
        if (tx >= arenaW - targetPx) { tx = arenaW - targetPx; vx = -Math.abs(vx); }
        if (ty >= arenaH - targetPx) { ty = arenaH - targetPx; vy = -Math.abs(vy); }

        // random direction change — frequency and sharpness scale with difficulty
        if (Math.random() < diff.changeChance) {
          var nudge = (Math.random() - 0.5) * diff.nudgeRange;
          var currentAngle = Math.atan2(vy, vx) + nudge;
          vx = Math.cos(currentAngle) * speed;
          vy = Math.sin(currentAngle) * speed;
        }

        target.style.left = tx + 'px';
        target.style.top = ty + 'px';

        // hit detection
        trackState.totalFrames++;
        var cx = trackState.cursorX;
        var cy = trackState.cursorY;
        var onTarget = trackState.mouseDown && cx >= tx && cx <= tx + targetPx && cy >= ty && cy <= ty + targetPx;

        if (onTarget) {
          trackState.onTargetFrames++;
          if (!trackState.isOnTarget) {
            trackState.isOnTarget = true;
            startTrackSound();
          }
        } else {
          if (trackState.isOnTarget) {
            trackState.isOnTarget = false;
            stopTrackSound();
          }
        }

        // update hud accuracy
        var acc = trackState.totalFrames > 0 ? Math.round((trackState.onTargetFrames / trackState.totalFrames) * 100) : 0;
        hud.querySelector('.hud-score').textContent = acc + '%';

        trackAnimFrame = requestAnimationFrame(loop);
      }

      trackAnimFrame = requestAnimationFrame(loop);
    }

    async function saveTrackScore(trackState) {
      if (!currentUser) return;
      var accuracy = trackState.totalFrames > 0 ? Math.round((trackState.onTargetFrames / trackState.totalFrames) * 100) : 0;
      var targetPx = selectedTrackSize === 'small' ? 20 : selectedTrackSize === 'large' ? 60 : 40;
      var { error } = await sb.from('scores').insert({
        user_id: currentUser.id,
        mode: 'track',
        grid_size: targetPx,
        duration: trackState.duration,
        score: accuracy,
        accuracy: accuracy,
        misses: 0,
        difficulty: selectedTrackDifficulty
      });
      if (error) console.error('track save error:', error);
    }

    async function getTopTrackScores(trackState) {
      if (!currentUser) return [];
      var targetPx = selectedTrackSize === 'small' ? 20 : selectedTrackSize === 'large' ? 60 : 40;
      var { data } = await sb.from('scores')
        .select('score, accuracy, created_at')
        .eq('user_id', currentUser.id)
        .eq('mode', 'track')
        .eq('grid_size', targetPx)
        .eq('duration', trackState.duration)
        .eq('difficulty', selectedTrackDifficulty)
        .order('score', { ascending: false })
        .limit(10);
      return data || [];
    }

    async function endTrackGame(trackState) {
      var accuracy = trackState.totalFrames > 0 ? Math.round((trackState.onTargetFrames / trackState.totalFrames) * 100) : 0;

      await saveTrackScore(trackState);
      var topScores = await getTopTrackScores(trackState);
      var isNewBest = topScores.length > 0 && topScores[0].score === accuracy;

      content.innerHTML = '';
      var wrap = document.createElement('div');
      wrap.className = 'results';

      var durLabel = trackState.duration >= 60 ? (trackState.duration / 60) + 'm' : trackState.duration + 's';
      var statsHtml =
        '<div>target <span>' + selectedTrackSize + '</span></div>' +
        '<div>difficulty <span>' + selectedTrackDifficulty + '</span></div>' +
        '<div>time <span>' + durLabel + '</span></div>';

      wrap.innerHTML =
        '<div class="results-score">' + accuracy + '%</div>' +
        '<div class="results-label">accuracy</div>' +
        (isNewBest ? '<div class="results-new-best">new personal best</div>' : '') +
        '<div class="results-stats">' + statsHtml + '</div>';

      var btn = document.createElement('button');
      btn.className = 'again-btn';
      btn.textContent = 'play again';
      btn.addEventListener('click', showTrackModeSelect);
      wrap.appendChild(btn);

      if (topScores.length > 0) {
        var hist = document.createElement('div');
        hist.className = 'history';
        hist.innerHTML = '<div class="history-title">your top 10</div>';
        topScores.forEach(function(s, i) {
          var d = new Date(s.created_at);
          var dateStr = (d.getMonth() + 1) + '/' + d.getDate();
          var row = document.createElement('div');
          row.className = 'history-row';
          row.innerHTML =
            '<div class="history-rank">' + (i + 1) + '</div>' +
            '<div class="history-score">' + s.score + '%</div>' +
            '<div class="history-acc">' + s.accuracy + '%</div>' +
            '<div class="history-date">' + dateStr + '</div>';
          hist.appendChild(row);
        });
        wrap.appendChild(hist);
      }

      content.appendChild(wrap);
    }

    // game
    function startGame(size) {
      var mode = selectedMode;
      var duration = mode === 'perfection' ? 0 : selectedDuration;
      gameState = {
        size: size, score: 0, misses: 0, timeLeft: duration,
        targets: new Set(), lastClicked: -1, mode: mode, duration: duration, track: 'grid'
      };
      content.innerHTML = '';

      // hud
      var hud = document.createElement('div');
      hud.className = 'hud';
      if (mode === 'perfection') {
        hud.innerHTML = '<div class="hud-score">0</div><div class="hud-mode">perfection</div><div class="hud-timer"></div>';
      } else {
        var timeLabel = duration >= 60 ? Math.floor(duration / 60) + ':' + ('0' + (duration % 60)).slice(-2) : duration + 's';
        hud.innerHTML = '<div class="hud-score">0</div><div class="hud-mode">' + mode + '</div><div class="hud-timer">' + timeLabel + '</div>';
      }
      content.appendChild(hud);

      // grid
      var grid = document.createElement('div');
      grid.className = 'grid';
      grid.style.gridTemplateColumns = 'repeat(' + size + ', 1fr)';
      var total = size * size;
      for (var i = 0; i < total; i++) {
        var cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.index = i;
        grid.appendChild(cell);
      }
      content.appendChild(grid);

      // spawn initial targets
      var numTargets = size <= 4 ? 3 : size >= 48 ? 6 : size >= 24 ? 5 : 4;
      for (var t = 0; t < numTargets; t++) spawnTarget(grid);

      // click handler
      for (var c = 0; c < grid.children.length; c++) {
        grid.children[c].addEventListener('mousedown', function(e) {
          e.preventDefault();
          if (this.classList.contains('target')) {
            gameState.score++;
            var clickedIdx = parseInt(this.dataset.index);
            gameState.lastClicked = clickedIdx;
            gameState.targets.delete(clickedIdx);
            this.classList.remove('target');
            spawnTarget(grid);
            hud.querySelector('.hud-score').textContent = gameState.score;
            playHitSound();
          } else {
            gameState.misses++;
            if (gameState.mode === 'perfection') {
              if (gameTimer) { clearInterval(gameTimer); gameTimer = null; }
              endGame();
            }
          }
        });
      }

      // timer (only for time mode)
      if (mode === 'time') {
        gameTimer = setInterval(function() {
          gameState.timeLeft--;
          var tl = gameState.timeLeft;
          var display = tl >= 60 ? Math.floor(tl / 60) + ':' + ('0' + (tl % 60)).slice(-2) : tl + 's';
          hud.querySelector('.hud-timer').textContent = display;
          if (gameState.timeLeft <= 0) {
            clearInterval(gameTimer);
            gameTimer = null;
            endGame();
          }
        }, 1000);
      }
    }

    function spawnTarget(grid) {
      var total = gameState.size * gameState.size;
      var available = [];
      for (var i = 0; i < total; i++) {
        if (!gameState.targets.has(i) && i !== gameState.lastClicked) available.push(i);
      }
      if (available.length === 0) return;
      var idx = available[Math.floor(Math.random() * available.length)];
      gameState.targets.add(idx);
      grid.children[idx].classList.add('target');
    }

    async function saveScore() {
      if (!currentUser) return;
      var total = gameState.score + gameState.misses;
      var accuracy = total > 0 ? Math.round((gameState.score / total) * 100) : 0;
      var { error } = await sb.from('scores').insert({
        user_id: currentUser.id,
        track: gameState.track || 'grid',
        mode: gameState.mode,
        grid_size: gameState.size,
        duration: gameState.duration,
        score: gameState.score,
        accuracy: accuracy,
        misses: gameState.misses
      });
      if (error) console.error('save error:', error);
    }

    async function getTopScores() {
      if (!currentUser) return [];
      var query = sb.from('scores')
        .select('score, accuracy, misses, created_at')
        .eq('user_id', currentUser.id)
        .eq('track', gameState.track || 'grid')
        .eq('mode', gameState.mode)
        .eq('grid_size', gameState.size);

      // only filter by duration for time mode
      if (gameState.mode === 'time') {
        query = query.eq('duration', gameState.duration);
      }

      var { data } = await query.order('score', { ascending: false }).limit(10);
      return data || [];
    }

    async function endGame() {
      var total = gameState.score + gameState.misses;
      var accuracy = total > 0 ? Math.round((gameState.score / total) * 100) : 0;
      var currentScore = gameState.score;

      await saveScore();

      var topScores = await getTopScores();
      var isNewBest = topScores.length > 0 && topScores[0].score === currentScore;

      content.innerHTML = '';

      var wrap = document.createElement('div');
      wrap.className = 'results';

      var statsHtml =
        '<div>accuracy <span>' + accuracy + '%</span></div>' +
        '<div>misses <span>' + gameState.misses + '</span></div>' +
        '<div>grid <span>' + gameState.size + 'x' + gameState.size + '</span></div>' +
        '<div>mode <span>' + gameState.mode + '</span></div>';
      if (gameState.mode === 'time') {
        var durLabel = gameState.duration >= 60 ? (gameState.duration / 60) + 'm' : gameState.duration + 's';
        statsHtml += '<div>time <span>' + durLabel + '</span></div>';
      }

      wrap.innerHTML =
        '<div class="results-score">' + currentScore + '</div>' +
        '<div class="results-label">score</div>' +
        (isNewBest ? '<div class="results-new-best">new personal best</div>' : '') +
        '<div class="results-stats">' + statsHtml + '</div>';

      var btn = document.createElement('button');
      btn.className = 'again-btn';
      btn.textContent = 'play again';
      btn.addEventListener('click', function() { showModeSelect(gameState.track || 'grid'); });
      wrap.appendChild(btn);

      if (topScores.length > 0) {
        var hist = document.createElement('div');
        hist.className = 'history';
        hist.innerHTML = '<div class="history-title">your top 10</div>';
        topScores.forEach(function(s, i) {
          var d = new Date(s.created_at);
          var dateStr = (d.getMonth() + 1) + '/' + d.getDate();
          var row = document.createElement('div');
          row.className = 'history-row';
          row.innerHTML =
            '<div class="history-rank">' + (i + 1) + '</div>' +
            '<div class="history-score">' + s.score + '</div>' +
            '<div class="history-acc">' + s.accuracy + '%</div>' +
            '<div class="history-date">' + dateStr + '</div>';
          hist.appendChild(row);
        });
        wrap.appendChild(hist);
      }

      content.appendChild(wrap);
    }

    // ── edit track ──

    function getTextOffset(container, node, offset) {
      var range = document.createRange();
      range.selectNodeContents(container);
      range.setEnd(node, offset);
      return range.toString().length;
    }

    function setCursorAtOffset(container, offset) {
      var walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, null, false);
      var pos = 0;
      var node;
      while (node = walker.nextNode()) {
        var len = node.textContent.length;
        if (pos + len >= offset) {
          var sel = window.getSelection();
          var range = document.createRange();
          range.setStart(node, offset - pos);
          range.collapse(true);
          sel.removeAllRanges();
          sel.addRange(range);
          return;
        }
        pos += len;
      }
    }

    function placeCursorAtEnd(container) {
      var sel = window.getSelection();
      var range = document.createRange();
      range.selectNodeContents(container);
      range.collapse(false);
      sel.removeAllRanges();
      sel.addRange(range);
    }

    function findWordBoundary(text, pos, direction) {
      if (direction === -1) {
        while (pos > 0 && text[pos - 1] !== ' ') pos--;
        return pos;
      } else {
        while (pos < text.length && text[pos] !== ' ') pos++;
        return pos;
      }
    }

    function pickRandomWordRange(text, minLen, maxLen) {
      var attempts = 0;
      while (attempts < 50) {
        var pos = Math.floor(Math.random() * (text.length - minLen));
        var start = findWordBoundary(text, pos, -1);
        var end = findWordBoundary(text, start + minLen, 1);
        var len = end - start;
        if (len >= minLen && len <= maxLen && start >= 0 && end <= text.length) {
          return { start: start, end: end };
        }
        attempts++;
      }
      var s = 0;
      var e = findWordBoundary(text, minLen, 1);
      return { start: s, end: Math.min(e, text.length) };
    }

    function renderEditText(highlights) {
      var text = editState.textContent;
      var editor = editState.editorEl;

      // save cursor offset before re-rendering
      var savedOffset = -1;
      var sel = window.getSelection();
      if (sel.rangeCount > 0 && editor.contains(sel.anchorNode)) {
        savedOffset = getTextOffset(editor, sel.anchorNode, sel.anchorOffset);
      }

      while (editor.firstChild) editor.removeChild(editor.firstChild);
      highlights.sort(function(a, b) { return a.start - b.start; });
      var pos = 0;
      highlights.forEach(function(hl) {
        if (hl.start > pos) {
          editor.appendChild(document.createTextNode(text.slice(pos, hl.start)));
        }
        var span = document.createElement('span');
        span.className = hl.className;
        span.textContent = text.slice(hl.start, hl.end);
        editor.appendChild(span);
        pos = hl.end;
      });
      if (pos < text.length) {
        editor.appendChild(document.createTextNode(text.slice(pos)));
      }

      // restore cursor position
      if (savedOffset >= 0) {
        savedOffset = Math.min(savedOffset, text.length);
        setCursorAtOffset(editor, savedOffset);
      }
    }

    function editSelectionHandler() {
      if (!editState || !editState.currentDrill) return;
      var type = editState.currentDrill.type;
      if (type === 'movement' || type === 'selection') {
        checkEditDrill();
      }
    }

    function loadEditText() {
      var idx;
      do {
        idx = Math.floor(Math.random() * editTextBlocks.length);
      } while (idx === editState.originalTextIndex && editTextBlocks.length > 1);
      editState.originalTextIndex = idx;
      editState.textContent = editTextBlocks[idx];
      editState.editorEl.textContent = editState.textContent;
    }

    function generateEditDrill() {
      var text = editState.textContent;
      if (text.length < 50) {
        loadEditText();
        text = editState.textContent;
      }

      var drills = editState.enabledDrills;
      var type = drills[Math.floor(Math.random() * drills.length)];
      var drill;

      if (type === 'movement') {
        var targetOffset = Math.floor(Math.random() * text.length);
        drill = { type: 'movement', targetOffset: targetOffset };
        var highlights = [];
        if (targetOffset < text.length) {
          highlights.push({ start: targetOffset, end: targetOffset + 1, className: 'edit-caret-target' });
        }
        renderEditText(highlights);
        editState.hintEl.textContent = 'move';

      } else if (type === 'selection') {
        var range = pickRandomWordRange(text, 4, 30);
        drill = { type: 'selection', targetStart: range.start, targetEnd: range.end };
        renderEditText([{ start: range.start, end: range.end, className: 'edit-hl-select' }]);
        editState.hintEl.textContent = 'select';

      } else if (type === 'deletion') {
        var range = pickRandomWordRange(text, 4, 25);
        var expected = text.slice(0, range.start) + text.slice(range.end);
        drill = { type: 'deletion', targetStart: range.start, targetEnd: range.end, expectedText: expected };
        renderEditText([{ start: range.start, end: range.end, className: 'edit-hl-delete' }]);
        editState.hintEl.textContent = 'delete';

      } else if (type === 'replace') {
        // pick a single word
        var words = [];
        var wi = 0;
        while (wi < text.length) {
          if (text[wi] === ' ') { wi++; continue; }
          var ws = wi;
          while (wi < text.length && text[wi] !== ' ') wi++;
          if (wi - ws >= 3) words.push({ start: ws, end: wi });
        }
        var picked = words[Math.floor(Math.random() * words.length)];
        var srcRange = { start: picked.start, end: picked.end };
        var srcText = text.slice(srcRange.start, srcRange.end);
        var dstOffset;
        var attempts = 0;
        do {
          dstOffset = Math.floor(Math.random() * text.length);
          attempts++;
        } while (Math.abs(dstOffset - srcRange.start) < 20 && attempts < 50);
        // ensure dst is at a word boundary
        dstOffset = findWordBoundary(text, dstOffset, -1);

        var afterRemove = text.slice(0, srcRange.start) + text.slice(srcRange.end);
        var adjustedDst = dstOffset > srcRange.end ? dstOffset - (srcRange.end - srcRange.start) : dstOffset;
        adjustedDst = Math.max(0, Math.min(adjustedDst, afterRemove.length));
        var expected = afterRemove.slice(0, adjustedDst) + srcText + afterRemove.slice(adjustedDst);
        drill = {
          type: 'replace', srcStart: srcRange.start, srcEnd: srcRange.end,
          dstOffset: dstOffset, expectedText: expected
        };

        var highlights = [
          { start: srcRange.start, end: srcRange.end, className: 'edit-hl-replace-src' }
        ];
        if (dstOffset < text.length) {
          highlights.push({ start: dstOffset, end: dstOffset + 1, className: 'edit-hl-replace-dst' });
        }
        // avoid overlapping highlights
        if (highlights.length === 2 && highlights[0].start <= highlights[1].end && highlights[1].start <= highlights[0].end) {
          highlights.pop();
        }
        renderEditText(highlights);
        editState.hintEl.textContent = 'replace';
      }

      editState.currentDrill = drill;
    }

    function checkEditDrill() {
      if (!editState || !editState.currentDrill) return;
      var drill = editState.currentDrill;
      var editor = editState.editorEl;
      var completed = false;

      if (drill.type === 'movement') {
        var sel = window.getSelection();
        if (sel.isCollapsed && sel.rangeCount > 0) {
          var cursorOffset = getTextOffset(editor, sel.anchorNode, sel.anchorOffset);
          if (cursorOffset === drill.targetOffset) {
            completed = true;
          }
        }

      } else if (drill.type === 'selection') {
        var sel = window.getSelection();
        if (!sel.isCollapsed && sel.rangeCount > 0) {
          var range = sel.getRangeAt(0);
          var selStart = getTextOffset(editor, range.startContainer, range.startOffset);
          var selEnd = getTextOffset(editor, range.endContainer, range.endOffset);
          if (selStart === drill.targetStart && selEnd === drill.targetEnd) {
            completed = true;
          }
        }

      } else if (drill.type === 'deletion') {
        var currentText = editor.textContent;
        if (currentText === drill.expectedText) {
          completed = true;
          editState.textContent = currentText;
        }

      } else if (drill.type === 'replace') {
        var currentText = editor.textContent;
        if (currentText === drill.expectedText) {
          completed = true;
          editState.textContent = currentText;
        }
      }

      if (completed) {
        editState.drillsCompleted++;
        editState.hudScoreEl.textContent = editState.drillsCompleted;
        playHitSound();
        editState.currentDrill = null;
        setTimeout(function() {
          if (editState) generateEditDrill();
        }, 150);
      }
    }

    function startEditGame() {
      editState = {
        drillsCompleted: 0,
        keystrokes: 0,
        timeLeft: selectedEditDuration,
        duration: selectedEditDuration,
        enabledDrills: selectedEditDrills.slice(),
        currentDrill: null,
        textContent: '',
        originalTextIndex: -1,
        editorEl: null,
        hudScoreEl: null,
        hudTimerEl: null,
        hintEl: null
      };

      content.innerHTML = '';

      // hud
      var hud = document.createElement('div');
      hud.className = 'hud';
      var hudScore = document.createElement('div');
      hudScore.className = 'hud-score';
      hudScore.textContent = '0';
      var hudMode = document.createElement('div');
      hudMode.className = 'hud-mode';
      hudMode.textContent = 'edit';
      var hudTimer = document.createElement('div');
      hudTimer.className = 'hud-timer';
      var timeLabel = selectedEditDuration >= 60
        ? Math.floor(selectedEditDuration / 60) + ':' + ('0' + (selectedEditDuration % 60)).slice(-2)
        : selectedEditDuration + 's';
      hudTimer.textContent = timeLabel;
      hud.appendChild(hudScore);
      hud.appendChild(hudMode);
      hud.appendChild(hudTimer);
      content.appendChild(hud);
      editState.hudScoreEl = hudScore;
      editState.hudTimerEl = hudTimer;

      // editor
      var editor = document.createElement('div');
      editor.className = 'edit-editor';
      editor.contentEditable = 'true';
      editor.spellcheck = false;
      editor.setAttribute('autocapitalize', 'off');
      editor.setAttribute('autocomplete', 'off');
      editor.setAttribute('autocorrect', 'off');
      content.appendChild(editor);
      editState.editorEl = editor;

      // hint
      var hint = document.createElement('div');
      hint.className = 'edit-hint';
      content.appendChild(hint);
      editState.hintEl = hint;

      // prevent formatting
      editor.addEventListener('paste', function(e) {
        e.preventDefault();
        var text = (e.clipboardData || window.clipboardData).getData('text/plain');
        document.execCommand('insertText', false, text);
        editState.keystrokes++;
        checkEditDrill();
      });

      editor.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') { e.preventDefault(); return; }
        if ((e.metaKey || e.ctrlKey) && ['b', 'i', 'u'].indexOf(e.key.toLowerCase()) !== -1) {
          e.preventDefault();
          return;
        }
        if (['Shift', 'Meta', 'Alt', 'Control', 'CapsLock'].indexOf(e.key) === -1) {
          editState.keystrokes++;
        }
      });

      editor.addEventListener('input', function() {
        checkEditDrill();
      });

      document.addEventListener('selectionchange', editSelectionHandler);

      loadEditText();
      generateEditDrill();
      setTimeout(function() {
        editor.focus();
      }, 50);

      // timer
      editTimer = setInterval(function() {
        editState.timeLeft--;
        var tl = editState.timeLeft;
        var display = tl >= 60 ? Math.floor(tl / 60) + ':' + ('0' + (tl % 60)).slice(-2) : tl + 's';
        editState.hudTimerEl.textContent = display;
        if (editState.timeLeft <= 0) {
          clearInterval(editTimer);
          editTimer = null;
          endEditGame();
        }
      }, 1000);
    }

    function endEditGame() {
      document.removeEventListener('selectionchange', editSelectionHandler);
      if (editTimer) { clearInterval(editTimer); editTimer = null; }

      var drills = editState.drillsCompleted;
      var keystrokes = editState.keystrokes;
      var duration = editState.duration;
      var drillsPerMinute = duration > 0 ? Math.round((drills / duration) * 60 * 10) / 10 : 0;

      content.innerHTML = '';

      var wrap = document.createElement('div');
      wrap.className = 'results';

      var statsHtml =
        '<div>rate <span>' + drillsPerMinute + '/min</span></div>' +
        '<div>keystrokes <span>' + keystrokes + '</span></div>' +
        '<div>time <span>' + (duration >= 60 ? (duration / 60) + 'm' : duration + 's') + '</span></div>' +
        '<div>drills <span>' + editState.enabledDrills.join(', ') + '</span></div>';

      wrap.innerHTML =
        '<div class="results-score">' + drills + '</div>' +
        '<div class="results-label">drills completed</div>' +
        '<div class="results-stats">' + statsHtml + '</div>';

      var btn = document.createElement('button');
      btn.className = 'again-btn';
      btn.textContent = 'play again';
      btn.addEventListener('click', showEditModeSelect);
      wrap.appendChild(btn);

      content.appendChild(wrap);
      editState = null;
    }

    function showEditModeSelect() {
      content.innerHTML = '';
      var wrap = document.createElement('div');
      wrap.className = 'mode-select';

      // row 1: drill type toggles (multi-select)
      var row1 = document.createElement('div');
      row1.className = 'mode-row';
      var label1 = document.createElement('div');
      label1.className = 'mode-row-label';
      label1.textContent = 'drills';
      row1.appendChild(label1);

      ['movement', 'selection', 'deletion', 'replace'].forEach(function(drill) {
        var btn = document.createElement('button');
        btn.className = 'mode-btn' + (selectedEditDrills.indexOf(drill) !== -1 ? ' selected' : '');
        btn.textContent = drill;
        btn.addEventListener('mousedown', function() {
          var idx = selectedEditDrills.indexOf(drill);
          if (idx !== -1) {
            if (selectedEditDrills.length <= 1) return;
            selectedEditDrills.splice(idx, 1);
            btn.classList.remove('selected');
          } else {
            selectedEditDrills.push(drill);
            btn.classList.add('selected');
          }
          localStorage.setItem('subsequence_edit_drills', JSON.stringify(selectedEditDrills));
        });
        row1.appendChild(btn);
      });
      wrap.appendChild(row1);

      // row 2: duration
      var row2 = document.createElement('div');
      row2.className = 'mode-row';
      var label2 = document.createElement('div');
      label2.className = 'mode-row-label';
      label2.textContent = 'time';
      row2.appendChild(label2);
      [{v: 30, l: '30s'}, {v: 60, l: '1m'}, {v: 180, l: '3m'}].forEach(function(d) {
        var btn = document.createElement('button');
        btn.className = 'mode-btn' + (d.v === selectedEditDuration ? ' selected' : '');
        btn.textContent = d.l;
        btn.addEventListener('mousedown', function() {
          selectedEditDuration = d.v;
          localStorage.setItem('subsequence_edit_duration', d.v);
          row2.querySelectorAll('.mode-btn').forEach(function(b) { b.classList.remove('selected'); });
          btn.classList.add('selected');
        });
        row2.appendChild(btn);
      });
      wrap.appendChild(row2);

      // start button
      var cont = document.createElement('button');
      cont.className = 'mode-btn';
      cont.textContent = 'start';
      cont.style.marginTop = '16px';
      cont.addEventListener('mousedown', function() { startEditGame(); });
      wrap.appendChild(cont);

      content.appendChild(wrap);
    }

    // drag game
    function startDragGame(size) {
      var mode = selectedMode;
      var duration = mode === 'perfection' ? 0 : selectedDuration;
      gameState = {
        size: size, score: 0, misses: 0, timeLeft: duration,
        mode: mode, duration: duration, track: 'drag',
        sourceIdx: -1, targetIdx: -1
      };
      content.innerHTML = '';

      // hud
      var hud = document.createElement('div');
      hud.className = 'hud';
      if (mode === 'perfection') {
        hud.innerHTML = '<div class="hud-score">0</div><div class="hud-mode">perfection</div><div class="hud-timer"></div>';
      } else {
        var timeLabel = duration >= 60 ? Math.floor(duration / 60) + ':' + ('0' + (duration % 60)).slice(-2) : duration + 's';
        hud.innerHTML = '<div class="hud-score">0</div><div class="hud-mode">' + mode + '</div><div class="hud-timer">' + timeLabel + '</div>';
      }
      content.appendChild(hud);

      // grid
      var grid = document.createElement('div');
      grid.className = 'grid';
      grid.style.gridTemplateColumns = 'repeat(' + size + ', 1fr)';
      grid.style.cursor = 'default';
      var total = size * size;
      for (var i = 0; i < total; i++) {
        var cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.index = i;
        cell.style.cursor = 'default';
        grid.appendChild(cell);
      }
      content.appendChild(grid);

      // spawn first pair
      document.body.classList.add('drag-track');
      spawnDragPair(grid);

      // drag state
      var dragGhost = null;
      var dragOffsetX = 0, dragOffsetY = 0;
      var isDragging = false;

      grid.addEventListener('mousedown', function(e) {
        var cell = e.target;
        if (!cell.classList.contains('drag-source')) return;
        isDragging = true;
        var rect = cell.getBoundingClientRect();
        dragOffsetX = e.clientX - rect.left;
        dragOffsetY = e.clientY - rect.top;

        dragGhost = document.createElement('div');
        dragGhost.className = 'drag-ghost';
        dragGhost.style.width = rect.width + 'px';
        dragGhost.style.height = rect.height + 'px';
        dragGhost.style.left = (e.clientX - dragOffsetX) + 'px';
        dragGhost.style.top = (e.clientY - dragOffsetY) + 'px';
        document.body.appendChild(dragGhost);

        cell.classList.add('drag-source-dragging');
        document.body.classList.add('dragging');
        e.preventDefault();
      });

      function dragMoveHandler(e) {
        if (!isDragging || !dragGhost) return;
        dragGhost.style.left = (e.clientX - dragOffsetX) + 'px';
        dragGhost.style.top = (e.clientY - dragOffsetY) + 'px';
      }

      function dragUpHandler(e) {
        if (!isDragging) return;
        isDragging = false;
        document.body.classList.remove('dragging');

        if (dragGhost) { dragGhost.remove(); dragGhost = null; }

        var sourceCell = grid.querySelector('.drag-source');
        if (sourceCell) sourceCell.classList.remove('drag-source-dragging');

        var dropTarget = document.elementFromPoint(e.clientX, e.clientY);
        if (dropTarget && dropTarget.classList.contains('drag-target')) {
          // hit
          gameState.score++;
          hud.querySelector('.hud-score').textContent = gameState.score;
          playHitSound();
          clearDragPair(grid);
          spawnDragPair(grid);
        } else if (dropTarget && dropTarget.classList.contains('cell') && !dropTarget.classList.contains('drag-source')) {
          // miss — dropped on wrong cell
          gameState.misses++;
          if (gameState.mode === 'perfection') {
            cleanup();
            endGame();
          }
        }
        // dropped on source or outside grid = cancel, no penalty
      }

      document.addEventListener('mousemove', dragMoveHandler);
      document.addEventListener('mouseup', dragUpHandler);

      function cleanup() {
        document.removeEventListener('mousemove', dragMoveHandler);
        document.removeEventListener('mouseup', dragUpHandler);
        document.body.classList.remove('dragging', 'drag-track');
        if (dragGhost) { dragGhost.remove(); dragGhost = null; }
      }

      gameCleanup = cleanup;

      // timer
      if (mode === 'time') {
        gameTimer = setInterval(function() {
          gameState.timeLeft--;
          var tl = gameState.timeLeft;
          var display = tl >= 60 ? Math.floor(tl / 60) + ':' + ('0' + (tl % 60)).slice(-2) : tl + 's';
          hud.querySelector('.hud-timer').textContent = display;
          if (gameState.timeLeft <= 0) {
            clearInterval(gameTimer);
            gameTimer = null;
            cleanup();
            endGame();
          }
        }, 1000);
      }
    }

    function spawnDragPair(grid) {
      var total = gameState.size * gameState.size;
      var available = [];
      for (var i = 0; i < total; i++) available.push(i);

      var srcIdx = available[Math.floor(Math.random() * available.length)];
      available.splice(available.indexOf(srcIdx), 1);
      var tgtIdx = available[Math.floor(Math.random() * available.length)];

      gameState.sourceIdx = srcIdx;
      gameState.targetIdx = tgtIdx;

      grid.children[srcIdx].classList.add('drag-source');
      grid.children[tgtIdx].classList.add('drag-target');
    }

    function clearDragPair(grid) {
      if (gameState.sourceIdx >= 0) grid.children[gameState.sourceIdx].classList.remove('drag-source', 'drag-source-dragging');
      if (gameState.targetIdx >= 0) grid.children[gameState.targetIdx].classList.remove('drag-target');
      gameState.sourceIdx = -1;
      gameState.targetIdx = -1;
    }

    // init
    var hash = window.location.hash.slice(1) || 'grid';
    var el = document.querySelector('nav a[data-tab="' + hash + '"]');
    if (el) {
      document.querySelector('nav a.active').classList.remove('active');
      el.classList.add('active');
    }
    initAuth();
  </script>
</body>
</html>
